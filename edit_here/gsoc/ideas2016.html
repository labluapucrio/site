
<h2>Ideas List - Google Summer of Code 2016</h2>

<ul>
<li><a href="#elasticsearch_update">
Update elasticsearch-lua
</a></li>
<li><a href="#elasticsearch_sailor">
Elasticsearch and Sailor
</a></li>
<li><a href="#elasticsearch_tests">
Improve elasticsearch-lua tests and build
</a></li>
<li><a href="#luarocks">
Next Generation of the LuaRocks test suite
</a></li>
<li><a href="#libscript">
Enhancements to LibScript, a cross-language scripting library
</a></li>
<li><a href="#typed">
Implement core Typed Lua in Haskell
</a></li>
<li><a href="#ceu">
Extending the online tutorial of CÃ©u with Emscripten and SDL
</a></li>
<li><a href="#netbsd">
Develop I/O API for NetBSD Kernel Lua
</a></li>
<li><a href="#cgilua">
Adapt CGILua SAPI launcher to explore all WSAPI features
</a></li>
<li><a href="#luasql">
Add support for prepared statements in LuaSQL
</a></li>
<li><a href="#peg">
Improving the Quality of Error Messages in PEG Parsers
</a></li>
<li><a href="#lad">
Assembler and Disassembler for Lua 5.3
</a></li>
<li><a href="#typedlua">
Add class-based object-oriented programming to Typed Lua
</a></li>
<li><a href="#luasec">
Improve the HTTPS module of LuaSec
</a></li>
</ul>

<br><hr>
<h3 id="elasticsearch_update">Update elasticsearch-lua</h3>

<h4>Brief explanation</h4>

<p>
<a href="https://www.elastic.co/products/elasticsearch">Elasticsearch</a>
is a distributed and scalable search engine.
It is written in Java and, besides the transport protocol (Java to Java), it
offers a very complete REST API accessed through <a href="http://json.org/">JSON</a>.
<a href="https://github.com/DhavalKapil/elasticsearch-lua/">elasticsearch-lua</a>
is a Lua library that allows Lua applications to easily comunicate with
Elasticsearch clusters.
</p>

<p>Currently, elasticsearch-lua is built on top of Elasticsearch 1.7 but does not implement all possible Elasticsearch features. Moreover, Elasticsearch is already in version 2.2 and many new features are available.</p>

<p>This project aims to implement the missing features from 1.7 and also add the new features from Elasticsearch 2.2.</p>

<h4>Expected results</h4>

<p>
An updated Lua client to access the Elasticsearch REST API compatible with the latest version (currently 2.2).
</p>

<h4>Knowledge prerequisites</h4>

<p>
<ul>
<li>Lua - medium</li>
<li>JSON - medium</li>
<li>HTTP - medium</li>
<li>Elasticsearch - medium</li>
</ul>
</p>

<h4>Skill level</h4>
<p>Medium</p>

<h4>Mentor</h4>
<p><a href="http://www.inf.puc-rio.br/~pmusa/">Pablo Musa</a></p>

<br><hr>
<h3 id="elasticsearch_sailor">Elasticsearch and Sailor</h3>

<h4>Brief explanation</h4>

<p>
<a href="https://www.elastic.co/products/elasticsearch">Elasticsearch</a>
is a distributed and scalable search engine.
It is written in Java and, besides the transport protocol (Java to Java), it
offers a very complete REST API accessed through <a href="http://json.org/">JSON</a>.
<a href="https://github.com/DhavalKapil/elasticsearch-lua/">elasticsearch-lua</a>
is a Lua library that allows Lua applications to easily communicate with
Elasticsearch clusters.
</p>

<p>
<a href="http://sailorproject.org/">Sailor</a> is a web framework in the Lua programming language. Like Lua, it is open sourced under the MIT License, which is extremely permissive. Sailor applications are structured in a model-view-controller (MVC) architecture.
</p>

<p>
This project aims the development of a search module that integrates elasticsearch-lua into Sailor.
</p>

<h4>Expected results</h4>

<p>
A search functionality that is easy to use and integrate to a website using Sailor. Internally,
a new form.search method in the form module that exposes a search text input and a search model similar to the current database one. 
</p>

<h4>Knowledge prerequisites</h4>

<p>
<ul>
<li>Lua - medium</li>
<li>Sailor - not required</li>
<li>Elasticsearch - basic</li>
<li>Web Development - medium</li>
</ul>
</p>

<h4>Skill level</h4>
<p>Easy/Medium</p>

<h4>Mentor</h4>
<p><a href="http://www.inf.puc-rio.br/~pmusa/">Pablo Musa</a></p>

<br><hr>
<h3 id="elasticsearch_tests">Improve elasticsearch-lua tests and build</h3>

<h4>Brief explanation</h4>

<p>
<a href="https://www.elastic.co/products/elasticsearch">Elasticsearch</a>
is a distributed and scalable search engine.
It is written in Java and, besides the transport protocol (Java to Java), it
offers a very complete REST API accessed through <a href="http://json.org/">JSON</a>.
<a href="https://github.com/DhavalKapil/elasticsearch-lua/">elasticsearch-lua</a>
is a Lua library that allows Lua applications to easily comunicate with
Elasticsearch clusters.
</p>

<p>
Currently, elasticsearch-lua has small build automation, only 19 library tests and no code coverage.
</p>

<p>This project aims to implement more robust build automation.</p>

<h4>Expected results</h4>

<p>
An integration for code coverage, automated build tests (already working) and a large set of tests that cover most part of the code.
</p>

<h4>Knowledge prerequisites</h4>

<p>
<ul>
<li>Lua - basic</li>
<li>Elasticsearch - basic/medium</li>
<li>Continous Integration - basic</li>
</ul>
</p>

<h4>Skill level</h4>
<p>Easy</p>

<h4>Mentor</h4>
<p><a href="http://www.inf.puc-rio.br/~pmusa/">Pablo Musa</a></p>

<br><hr>
<h3 id="libscript">Enhancements to LibScript, a cross-language scripting library</h3>
<h4>Brief explanation</h4>

<p><a href="http://hishamhm.github.io/libscript">LibScript</a>
is a library for cross-language scripting: it allows code written in one scripting
language to call function written in a different language, and allows C programs
to support various scripting languages via a single interface. LibScript currently
supports Python, Ruby, Lua and Perl, and it only supports passing simple values
as arguments (strings, numbers, booleans).</p>

<p>This project has two goals:</p>

<ul>
<li>supporting a wider set of functions - support passing and receiving structured
data types such as lists and dictionaries. An idea of how to do this to pass data
by-copy, using JSON as an interchange format between languages.</li>
<li>supporting more languages - two languages that would be useful to support would
be JavaScript (writing a LibScript plugin that links the V8 virtual machine),
and <a href="https://www.r-project.org">R</a> (giving many languages access to the vast array of statistical
libraries available in <a href="http://cran.us.r-project.org/">CRAN</a>).</li>
</ul>

<h4>Expected results</h4>
<ul>
<li>Enhancements to the existing LibScript plugins, supporting structured data types.</li>
<li>New plugins supporting additional languages</li>
</ul>

<h4>Knowledge prerequisites</h4>
<ul>
<li>C programming - must be comfortable with C code, working with C libraries and learning their APIs</li>
<li>Unix shell and tools - Makefile, shell scripting (not being scared of <a href="http://www.sourceware.org/autobook/">Autotools</a> is a bonus -- if scared, we'll work on it!)</li>
<li>Previous experience in <i>some</i> scripting language - any of Python, Ruby, Lua, Perl, JavaScript, etc.</li>
<li>Experience with, or willingness to quickly learn Git and the Github workflow</li>
<li>Previous experience embedding any scripting language in a C application is a bonus</li>
</ul>

<h4>Skill level</h4>
<p>Medium/advanced</p>

<h4>Mentor</h4>
<p>
<a href="http://hisham.hm/">Hisham Muhammad</a>
</p>

<br><hr>
<h3 id="luarocks">Next Generation of the LuaRocks test suite</h3>
<h4>Brief explanation</h4>

<p><a href="http://luarocks.org">LuaRocks</a>
is the package manager for Lua modules. It has a test suite with about 80%
coverage. However, the test suite is implemented as a big shell script that
only does black-box testing: it calls <tt>luarocks</tt> as an external
application. Further, it only checks for success and failure of the process,
and not if it executed the expected actions, and it runs only on Linux.
</p>

<p>The idea of this project is to port the test suite to Lua,
using 
<!--<a href="http://olivinelabs.com/busted/">Busted</a>.-->
<a href="https://github.com/Olivine-Labs/busted">Busted</a>.
This
will allow us to extend the test suite by writing smarter tests
that check its behavior, write white-box tests of the internals,
and also port the test suite to other platforms.</p>

<h4>Expected results</h4>
<ul>
<li>A new test suite, written in Lua.</li>
<li>Improved code coverage, by adding white-box tests for parts that are hard-to reach
via black-box testing.</li>
<li>Initial results running the test suite on Windows (even if we can't run all tests at first).</li>
<li>Integrated code coverage results, merging the Linux and Windows runs.</li>
</ul>

<h4>Knowledge prerequisites</h4>
<ul>
<li>Lua</li>
<li>Unix shell and tools - basic shell scripting in order to understand the <a href="https://github.com/keplerproject/luarocks/blob/master/test/testing.sh">current test suite</a></li>
<li>Experience with, or willingness to quickly learn Git and the Github workflow</li>
</ul>

<h4>Skill level</h4>
<p>Easy/Medium</p>

<h4>Mentor</h4>
<p>
<a href="http://hisham.hm/">Hisham Muhammad</a>
</p>

<br><hr>
<h3 id="typed">Implement core Typed Lua in Haskell</h3>
<h4>Brief explanation</h4>

<p><a href="https://github.com/andremm/typedlua">Typed Lua</a>
is an optional type system for Lua, and its main goal is to
provide static type checking for Lua.
To do that, Typed Lua extends the syntax of Lua 5.3 to introduce
optional type annotations, and performs local type inference
to detect more precise types for unannotated expressions.
</p>

<p>The aim of this project is to implement core Typed Lua in Haskell,
as a tool to test new features and reason about new typing rules for Typed Lua.
Core Typed Lua limits control flow to if and while statements;
it has explicit type annotations, explicit scope for variables,
explicit method declarations, and explicit method calls.
</p>

<h4>Expected results</h4>

<ul>
<li>A type checker written in Haskell that analyses code written in core Typed Lua.</li>
</ul>

<h4>Knowledge prerequisites</h4>

<ul>
<li>Lua (for understanding regular Typed Lua implementation).</li>
<li>Haskell (for implementing the project).</li>
<li>Type Systems (for understanding the typing rules).</li>
<li>Git (the project repository should be in github).</li>
</ul>

<h4>Skill level</h4>
<p>Advanced</p>

<h4>Mentor</h4>
<p>
<a href="mailto:amaidl@inf.puc-rio.br">AndrÃ© Murbach Maidl</a>
</p>

<br><hr>
<h3 id="ceu">Extending the online tutorial of CÃ©u with Emscripten and SDL</h3>

<h4>Brief explanation</h4>

<p><a href="http://ceu-lang.org/">CÃ©u</a> is a programming language that targets system-level development of reactive systems. The language is under development at the LabLua since 2011. For a little introduction about CÃ©u, please watch the video in <a href="http://ceu-lang.org/">our front page</a>. CÃ©u appeared in <a href="http://www.future-programming.org/2014/program.html">Future Programming</a> and <a href="http://curry-on.org/2015/sessions/structured-synchronous-programming.html">Curry-On</a> workshops.</p>

<p>Currently, the online tutorial of CÃ©u executes a simulation at the server side:</p>

<a href="http://ceu-lang.org/try.php">http://ceu-lang.org/try.php</a>

<p>The tutorial works as follows:</p>

<ol>
<li>User reads about a new concept (`top/left` of the page).</li>
<li>User reads an accompanying example (`top/right`) with an input (`bottom/right`).</li>
<li>User clicks "Run" (`top/right`)
<ol>
    <li>Code is sent to the server.</li>
    <li>Server compiles and executes the code with the provided input.</li>
    <li>User gets an output (`bottom/left`).</li>
</ol>
<li>User changes the code and input to experiment with it (going to step 3).</li>
<li>User advances in the tutorial.</li>
</ol>

<p>
The server-side approach does not provide a reactive and real-time experience, 
which are the ultimate objectives of the language. We want the online tutorial to offer a more interactive experience for learners 
of CÃ©u. The client-side tutorial would work as follows:
</p>

<ol>
<li>User reads about a new concept (`top/left` of the page).
<li>User sees an example (`top/right`) <strike>with an input (`bottom/right`)</strike>.
<li>User clicks "Run" (`top/right`):
<ol>
    <li>Code is sent to the server.
    <li>Server compiles the code <strike>with the provided input</strike> to Javascript and 
       returns it to the client.
    <li>User <strike>gets an output (`bottom/left`)</strike> interacts with the program in 
       real time.
</ol>
<li>User changes the code <strike>and input</strike> to experiment with it (going to step 3).
<li>User advances in the tutorial.
</ol>

<h4>Tools</h4>

<p>
<a href="http://libsdl.org/">SDL</a> is a C-based and cross-platform development library that provides access to 
audio, keyboard, mouse, joystick, and graphics hardware.
Given that CÃ©u interacts well with C, combining CÃ©u and SDL is a viable option 
for building a visually-appealing interactive tutorial.
<a href="https://github.com/kripken/emscripten/">Emscripten</a> is an LLVM-to-JavaScript compiler. SDL has already <a href="https://github.com/kripken/emscripten/issues/2404">been ported to Emscripten</a>.
</p><p>
Putting it all together, we can build an interactive tutorial for CÃ©u that runs 
in the browser at the client side.
</p><p>
The bulk of the project is to implement this synergy between C, CÃ©u, SDL, and 
Emscripten.
However, the project also involves other tools: Linux, Git, HTML and PHP.
</p>

<h4>Expected results</h4>

<ul><li>A working interactive online tutorial for CÃ©u.</ul>

<p>
As an ultimate goal, we would like to build an incremental tutorial based on 
<a href="https://vimeo.com/110512582">this video</a>.

<h4>Prerequisites</h4>

<p>
We expect the applicants to know <b>C</b> well and to develop minimum familiarity 
with the important tools before the project kicks off.
</p><p>
For this reason, we will ask the applicants to perform two activities *before* 
the application period:
</p>
<ol>
<li>Create a repository on *Github* and write a simple "Hello World" page using
   Emscripten and SDL.
<li>Install CÃ©u and compile some existing SDL examples (without Emscripten).
</ol>

<p>
Both activities should be simple, i.e., nothing more than following tutorials 
on the web.
</p>

<h4>How to apply</h4>

<ul>
<li><a href="https://gitter.im/fsantanna/ceu-gsoc-2016">Get in touch</a>
<li>Follow the official GSoC instructions.
<li>Follow the LabLua instructions.
</ul>

<h4>Skill level</h4>

<p>
Medium
</p>

<h4>Mentor</h4>

<p>
<a href="http://www.ceu-lang.org/chico">Francisco Sant'Anna</a>
</p>

<br/><hr/>

<h3 id="netbsd">Develop I/O API for NetBSD Kernel Lua</h3>

<h4>Brief explanation</h4>

<p>
<a href="http://www.netbsd.org">The NetBSD Operating System</a> has a
kernel-level Lua interpreter version for
<a href="http://netbsd.org/~lneto/dls14.pdf">scripting its kernel</a>.
For example, it allows users to
<a href="http://netbsd.org/~lneto/eurobsdcon14.pdf">filter packets
using Lua scripts</a>.
</p>
<p>
The main difference between kernel Lua and regular user-level Lua is
that kernel Lua doesn't have support for standard libraries that
depend on operating system (e.g., io and os) and for floating-point
numbers. The purpose of this project is to develop kernel Lua
libraries to provide I/O functionality to kernel scripts. This API
should provide access both for file system and network. It should be
implemented as
<a href="http://www.home.unix-ag.org/bmeurer/NetBSD/howto-lkm.html">NetBSD
loadable kernel modules</a> binding the kernel internal implementation
for files and sockets user-level API.
</p>

<h4>Expected results</h4>

<ul>
<li>Kernel Lua File Library</li>
<li>Kernel Lua Socket Library</li>
<li>Documentation and Benchmarks</li>
</ul>

<h4>Knowledge prerequisites</h4>

<p>
C, Lua, OS  (and some courage :) )
</p>

<h4>Skill level</h4>

<p>
Advanced
</p>

<h4>Mentor</h4>

<p>
<a href="mailto:lneto@NetBSD.org">Lourival Vieira Neto</a>
</p>

<br><hr>
<h3 id="cgilua">Adapt CGILua SAPI launcher to explore all WSAPI features.</h3>
<h4>Brief explanation</h4>

<p><a href="http://keplerproject.github.io/cgilua/">
CGILua</a> is a tool for creating dynamic Web pages and manipulating input
data from Web forms.  One of advantages of CGILua is its abstraction
of the underlying Web server. CGILua can be used with a variety of Web
servers and, for each server, with different launchers. A launcher is
responsible for the interaction of CGILua and the Web server, for example
using ISAPI on IIS or mod_lua on Apache. The reference implementation
of CGILua launchers is Kepler.</p>

<p> <a href="http://keplerproject.github.io/wsapi/">WSAPI</a>
is an API that abstracts the web server from Lua web
applications. WSAPI provides a set of helper libraries that help with
request processing and output buffering.</p>

<p>Actually CGILua has an implementation of an abstract underlying server
which is almost the same of WSAPI itself. This project proposes a
reimplementation of this layer (called SAPI) to explore WSAPI fully. This
should improve the performance and simplify maintenance.</p>

<h4>Expected results</h4>
<ul>
<li>Rewrite CGILua library to dispense SAPI module and use WSAPI directly.</li>
</ul>

<h4>Knowledge prerequisites</h4>
<p>Advanced Lua programming is mandatory, since both tools (CGILua and WSAPI)
are not naive software. A good understanding of the Lua environment
concept is particularly necessary in this project.</p>

<p>Web programming experience can be very helpful especially to understand
the context of use of these tools.</p>

<h4>Skill level</h4>
<p>Medium</p>

<h4>Mentor</h4>
<p>TomÃ¡s Guisasola</p>

<br><hr>
<h3 id="luasql">Add support for prepared statements in LuaSQL</h3>
<h4>Brief explanation</h4>
<p><a href="http://www.keplerproject.github.io/luasql/">
LuaSQL</a> is a generic interface from Lua to a DBMS.
It aims at portability over performance, but it allows extensions to
suit the particularities of each DBMS.</p>

<p>The inclusion of support for prepared statements in LuaSQL has been
discussed thoroughly some time ago, but since each DBMS offers very
different APIs there is no standard that could be defined to assure
portability between them.
Anyway the demand persists.</p>

<p>This project proposes the addition of a minimal API that would allow
each driver to implement prepared statements according to its DBMS
restrictions.</p>

<h4>Expected results</h4>
<ul>
<li>Adapt the API to each LuaSQL driver according to its particularities</li>
<li>Implement the new functions to each driver</li>
<li>Test and document everything</li>
</ul>

<h4>Knowledge prerequisites</h4>
<p>C, Lua and C API for Lua:</p>

<ul>
<li>C is mandatory.</li>
<li>Knowledge of the C API for Lua is mandatory, although it is not too
difficult to be learned during the project.</li>
<li>Basic programming in Lua is very helpful, but not mandatory, since
the examples and test-cases are very simple.</li>
</ul>

<h4>Skill level</h4>
<p>Hard</p>

<h4>Mentor</h4>
<p>TomÃ¡s Guisasola</p>

<br/><hr/>

<h3 id="peg">Improving the Quality of Error Messages in PEG Parsers</h3>

<h4>Brief explanation</h4>

<p>
<a href="http://bford.info/pub/lang/peg">Parsing Expression Grammars</a> (PEGs)
are an expressive formalism for designing and implementing top-down parsers with local backtracking.
An issue that users of PEG-based parsers face is poor reporting of syntax errors on the part of PEG-based parsers.
<a href="http://www.inf.puc-rio.br/~roberto/docs/sblp2013-1.pdf">Labeled failures</a> are an extension to PEGs that aims
to address this issue by annotating a PEG with labels corresponding to syntax errors,
improving the quality of error messages generated by a PEG-based parser.
</p>

<p>
<a href="https://github.com/sqmedeiros/lpeglabel/">LPegLabel</a> is an extension of the
<a href="http://www.inf.puc-rio.br/~roberto/lpeg/">LPeg</a> tool that provides an implementation of PEGs with labeled failures. 
Labels can be used to signal different kinds of errors and to specify which alternative in a labeled ordered choice
should handle a given label. 
</p>

<p>The goal of this project is to rewrite the parsers of some Lua libraries,
such as the module <i>re</i> from LPeg and <i>lua-parser</i>, by using LPegLabel.
After this rewriting we should get parsers with better error messages.
</p>


<h4>Tools</h4>

<p>
<ul>
  <li><a href="https://github.com/sqmedeiros/lpeglabel/">LPegLabel</a>
  <li><a href="http://www.inf.puc-rio.br/~roberto/lpeg/">LPeg</a>
  <li>Lua libraries whose parsers will be rewritten
</ul> 
</p>


<h4>Expected results</h4>

<p>
<ul>
  <li>The rewriting of at least 3 parsers by using LPegLabel
  <li>A proper documentation
</ul>
</p>

<p>
A marginal result would be the improvement of the LPegLabel tool
based on the difficulties found during the project.
</p>


<h4>Prerequisites</h4>

<p>
We expect the applicants to know <b>parsing</b> well and
to develop familiarity with LPeg and LPegLabel before the project starts.
</p>

<p>
For this reason, we may ask the applicants to perform some activities
<b>before</b> the application period.
</p>


<h4>How to apply</h4>

<p>
<ul>
<li>Get in touch.
<li>Follow the official GSoC instructions.
<li>Follow the LabLua instructions.
</ul>
</p>


<h4>Skill level</h4>

<p>
Medium
</p>


<h4>Mentor</h4>

<p>
<a href="https://sites.google.com/site/sqmedeiros/">SÃ©rgio Medeiros</a>
</p>

<br><hr>
<h3 id="lad">Assembler and Disassembler for Lua 5.3</h3>
<h4>Brief explanation</h4>

<p>
Lua is a dynamically typed programming language that runs by interpreting
bytecode for a register-based machine.
More precisely, Lua programs are interpreted indirectly from source code,
that is, they are compiled to bytecode and then executed by the Lua Virtual Machine.
This process is done during code execution and it is transparent to final users.
</p>

<p>
The aim of this project is to create a disassembler and an assembler for Lua 5.3.
The disassembler should generate assembly code from either Lua code or
bytecode, while the the assembler ought to generate Lua bytecode from
assembly code.
The assembly syntax should be expressive enough to encode all the instructions
that are available at Lua VM.
</p>

<h4>Expected results</h4>

<ul>
<li>A disassembler script that converts Lua code/bytecode into assembly instructions.</li>
<li>An assembler script that converts assembly instructions into executable Lua bytecode.</li>
</ul>

<h4>Knowledge prerequisites</h4>

<ul>
<li>Lua (the project should be written in Lua).</li>
<li>C (it is important to read the implementation of Lua VM).</li>
<li>Git (the project repository should be in github).</li>
<li>LPeg is a plus (the assembler parser can be written with LPeg).</li>
</ul>

<h4>Skill level</h4>
<p>Easy</p>

<h4>Mentor</h4>
<p>
<a href="mailto:amaidl@inf.puc-rio.br">AndrÃ© Murbach Maidl</a>
</p>

<br><hr>

<h3 id="typedlua">Add class-based object-oriented programming to <a href="https://github.com/andremm/typedlua">Typed Lua</a></h3>

<h4>Brief explanation</h4>

<p>Typed Lua is a strict superset of Lua that provides optional
type annotations, and compile-time type checking.
More precisely, Typed Lua is implemented as a programming language
that extends Lua syntax to add optional type annotations.
The compiler uses static types to perform compile-time type checking,
but also allows Lua code to coexist with Typed Lua code, and generate
Lua code that runs in unmodified Lua implementations.</p>

<h4>Expected results</h4>

<p>Typed Lua intended use is as an application language, and we view that
policies for organizing a program in modules and writing object-oriented
programs should be part of the language and enforced by its optional type
system. An application language is a programming language that helps
programmers develop applications from scratch until these applications
evolve to complex systems rather than just scripts.
This project aims to add class-based object-oriented programming to
Typed Lua through the definition of classes and interfaces,
as a way to help Lua programmers better structure their code.
The backend code generator should be a plugin, so the programmers
can choose which OO style or library they want to use.</p>

<h4>Knowledge prerequisites</h4>

<p>Lua, Object-Oriented Programming, and Type Systems</p>

<h4>Skill level</h4>

<p>Hard</p>

<h4>Mentor</h4>

<p><a href="http://www.dcc.ufrj.br/~fabiom/">Fabio Mascarenhas</a></p>

<br/><hr/>

<h3 id="luasec">Improve the HTTPS module of LuaSec</h3>
<h4>Brief explanation</h4>

<p>
  <a href="https://github.com/brunoos/luasec/wiki" target="_blank">LuaSec</a>&#39;s HTTPS
  module was built on top
  of <a href="http://w3.impa.br/~diego/software/luasocket/" target="_blank">LuaSocket</a>&#39;s
  HTTP and presents some problems due to limited integration.
</p>
<p>
  The aim of this project is to improve HTTPS module, fixing the
  issues and adding some new features.
</p>

<h4>Expected results</h4>

<ul>
  <li>Turn the module more self-contained, fixing the dependency problem.</li>
  <li>Add new features: proxy, SNI (Server Name Indication), etc.</li>
  <li>Support to HTTP/2 is a plus.</li>
</ul>

<h4>Knowledge prerequisites</h4>

<ul>
  <li>C, Lua, Git, HTTP protocol.</li>
</ul>

<h4>Skill level</h4>
<p>Easy / Medium</p>

<h4>Mentor</h4>
<p>
<a href="mailto:brunoos@inf.ufg.br" target="_blank">Bruno Silvestre</a>
</p>

<!--

<br><hr>
<h3 id="vlc">Multi-CPU usage in VLC</h3>
<h4>Brief explanation:</h4>

<p><a href="https://wiki.videolan.org/VLC_media_player/">VLC </a> is a free and open source cross-platform multimedia player and framework that plays most multimedia files as well as DVD, Audio CD, VCD, and various streaming protocols. Lua scripts can be added to VLC for tasks such as playlist construction and service discovery. Such tasks may involve a lot of parsing and communication and could benefit from using multiple CPUs when available. The purpose of this project is to include support for multi-CPU usage in VLC, using
<a href="http://askyrme.github.io/luaproc/">luaproc</a>,
 a library that allows programmers to create multiple independent execution flows of Lua code that can run inparallel, communicating only via message-passing.</p>

<h4>Expected results:</h4>
<p>Multi-CPU support in VLC.</p>

<h4 id="knowledgeprerequisite">Knowledge prerequisite:</h4>
<p>C, Lua</p>

<h4>Skill level:</h4>
<p>Medium</p>

<h4>Mentor:</h4>
<p>Alexandre Skyrme</p>

<br><hr>
<h3 id="wireshark">Multi-CPU usage in wireshark</h3>
<h4>Brief explanation:</h4>

<p>The 
<a href="http://www.wireshark.org/">
wireshark network protocol analyser</a> allows programmers to use Lua to write dissectors, post-dissectors and taps. Dissectors are protocol analysers, while post-dissectors are executed after all others dissectors, and taps are used to collect information after packet dissection. Protocol dissection can involve time constraints, and it would be nice to benefit from multi-CPU processing power in dissector script. The purpose of this project is to include support for multi-CPU usage in wireshark, using 
<a href="http://askyrme.github.io/luaproc/">luaproc</a>,
a library that allows programmers to create multiple independent execution flows of Lua code that can run inparallel, communicating only via message-passing.</p>

<h4>Expected results:</h4>
<p>We expect the support for Multi-CPU usage in wireshark.</p>

<h4 id="knowledgeprerequisite">Knowledge prerequisite:</h4>
<p>C, Lua</p>

<h4>Skill level:</h4>
<p>Medium</p>

<h4>Mentor:</h4>
<p>Alexandre Skyrme</p>


<br><hr>
<h3 id="loski">Develop a library for Lua 
that allows Lua programs to access features provided by the platform's underlying operating system (OS) kernel, such as process control, network access, file system, event notification, etc.</h3>

<h4>Brief explanation</h4>
<p>Standard Lua distribution is based mostly on standard ANSI C libraries only. Therefore, many functionalities provided by modern platforms (like process control, file system operations, network communication, kernel event notification, etc.) are only available through third-party libraries that are developed independently and might not integrate.</p>

<p>The project has three main goals:</p>

<ul>
<li>Design a simple and easy API that allows for different implementations over various platforms (POSIX, Linux, MacOSX, Windows, etc.) yet allowing use of a basic set of features that are provided by most popular plataforms.</li>
<li>Design an internal architecture that facilitate the replacement of the actual implementation of the features provided by the library (create process, use sockets, inspect file systems, etc). This is important to make porting the library to other platoforms easier.</li>
<li>Provide a basic/standard implementation of features provided by the library based on the codebase of existing Lua libraries that already export features of the underlying platform like 
<a href="http://w3.impa.br/~diego/software/luasocket/">LuaSocket</a>,
<a href="http://keplerproject.github.io/luafilesystem/">
LuaFileSystem</a> and others.</li>
</ul>

A prototype for the proposed library is available 
<a href="https://github.com/renatomaia/loski">
here</a>.

<h4>Expected results</h4>

<p>A set of Lua libraries implemented at least in one major operating system platform. The library shall provide support for:</p>

<ul>
<li>Creation and manipulation of processes, and possibly inter-process comunication mechanisms, such as pipes.</li>
<li>Creation and maniputation of sockets (TCP and UDP).</li>
<li>Inspection of the local file system, possibly including file attributes and permissions.</li>
<li>Notification of kernel events like process termination, socket data availability, file modification, etc.</li>
</ul>

<p>The implementation shall also be flexible enough to facilitate the portability for other platforms.</p>

<h4>Knowledge prerequisites</h4>
<ul>
<li>Programming in C.</li>
<li>Familiarity with concepts of the Lua language.</li>
<li>Programming with the system API of some popular platform, such as Linux, FreeBSD, Windows, etc.</li>
</ul>

<h4>Skill level</h4>
<p>Hard</p>

<h4>Mentor</h4>

<p>Renato Maia</p>

-->
