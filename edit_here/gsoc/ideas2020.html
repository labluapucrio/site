
<h2>Ideas List - Google Summer of Code 2020</h2>

<ul>
    <li><a href="#lpeg">
    A Parser Generator with Semi-Automatic Error Recovery based on LPeg(Label)
    </a></li>

    <li><a href="#ktls">
    Lua Hook on kTLS
    </a></li>

    <li><a href="#luaformatter">
    Lazy Configuration validator for LuaFormatter
    </a></li>

    <li><a href="#pallene">
    Closures in Pallene
    </a></li>
</ul>

<br><hr>
<h3 id="lpeg">A Parser Generator with Semi-Automatic Error Recovery based on LPeg(Label)</h3>

<h4>Brief explanation</h4>

<p>
<a href="http://bford.info/pub/lang/peg" target="_blank">
Parsing Expression Grammars</a> (PEGs)
are an expressive formalism for the design and implementation of top-down parsers 
with local backtracking.
<a href="http://www.inf.puc-rio.br/~roberto/lpeg/" target="_blank">LPeg</a> 
is a tool that provides an implementation of PEGs for Lua, while 
<a href="https://github.com/sqmedeiros/lpeglabel/" target="_blank">LPegLabel</a> 
is an extension
of LPeg with some facilities for error reporting and recovery.
</p>

<p>The goal of this project is to build a parser generator on top of the new version of LPegLabel.
This new tool should make easier the description of a parser for a
programming language and should also implement a
<a href="https://arxiv.org/abs/1905.02145" target="_blank"> conservative algorithm</a>
to automatically annotate a PEG with labels, in order to provide an automatic error
recovery mechanism.
</p>

<h4>Tools</h4>

<p>
<ul>
<li><a href="https://github.com/sqmedeiros/lpeglabel/" target="_blank">LPegLabel</a>
<li><a href="http://www.inf.puc-rio.br/~roberto/lpeg/" target="_blank">LPeg</a>
</ul> 
</p>


<h4>Expected results</h4>

<p>
<ul>
<li>A parser generator tool
<li>The (re)writing of at least 2 parsers with the new tool,
including <a href="https://github.com/andremm/lua-parser" target="_blank">
<i>lua-parser</i></a>,
with a robust error recovering mechanism. 
<li>A proper documentation
</p>

</ul>


<h4>Prerequisites</h4>

<p>
We expect the applicants to have a solid knowledge of <i>parsing</i> and
to develop familiarity with LPeg and LPegLabel before the project starts.
The applicant should have used at least one parser generator tool,
such as yacc/bison, ANTLR, JavaCC, PEG.js, etc.
</p>

<p>
For this reason, we will ask the applicants to perform some activities
<b>before</b> the application period.
</p>

<h4>Skill level</h4>

<p>
Advanced
</p>


<h4>Mentor</h4>

<p>
<a href="https://sites.google.com/site/sqmedeiros/" target="_blank">
SÃ©rgio Medeiros</a>
</p>

<br><hr>
<h3 id="ktls">Lua Hook on kTLS</h3>

<h4>Brief explanation</h4>

<p>
<a href="https://github.com/luainkernel/lunatik" target="_blank">Lunatik</a>
is a kernel-level Lua interpreter version for scripting the
Linux kernel. For example, it allows users to filter packets using Lua
scripts. 
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/networking/tls.rst?h=v5.5" target="_blank">kTLS</a>
is a new socket type provided by Linux that
transparently handles the encryption and decryption of TLS messages.
        <p>
<a href="https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp_ulp.c" target="_blank">ULP (Upper Layer Protocol)</a>
is a new feature merged recently in the
Linux kernel which allows user-space programs to attach 
<a href="https://en.wikipedia.org/wiki/OSI_model#Layer_7:_Application_Layer" target="_blank">
L7 functionalities</a> to the in-kernel socket structure. kTLS is implemented
via ULP.
<p>
The purpose of this project is to implement a kernel level Lua hook
inside the kTLS infrastructure. This way we could use Lua scripts to
inspect the contents of the HTTP messages transparently inside the
kernel.
</p>

<h4>Expected results</h4>

<p>
<ul>
<li>Lua hook inside kTLS
<li>A reference application
<li>Documentation and benchmarks
</p>

</ul>


<h4>Prerequisites</h4>

<p>
C, Lua, make, OS, networking (and some courage ;))
</p>

<h4>Skill level</h4>

<p>
Advanced
</p>


<h4>Mentor</h4>

<p>
<a href="mailto:pctammela@gmail.com">Pedro Tammela</a>
</p>

<br><hr>
<h3 id="luaformatter">Lazy Configuration validator for LuaFormatter</h3>

<h4>Brief explanation</h4>

<p>
<a href=" https://github.com/Koihik/LuaFormatter" target="_blank">LuaFormatter</a>
is a code formatter for Lua inspired by LLVM's
<a href="https://clang.llvm.org/docs/ClangFormat.html" target="_blank">'clang-format'</a>.
It helps projects keep a even code style in Lua


scripts while being easy to integrate with many different code
editors.
<p>
The purpose of this project is to implement a lazy configuration
validator. Right now, LuaFormatter doesn't check if the configuration
values makes sense before using it. For example, a clueless user could
use a negative value in a field where the range expected is [0,
&infin;).
<p>
We expect the validator to detect this kind of error and report to the
user in a nice, helpful way.
</p>

<h4>Expected results</h4>

<p>
<ul>
<li>Lazy configurator validator
<li>Unit tests
<li>Documentation
</p>

</ul>


<h4>Prerequisites</h4>

<p>
C++/C, Git
</p>

<h4>Skill level</h4>

<p>
Easy
</p>


<h4>Mentors</h4>

<p>
<a href="mailto:pctammela@gmail.com">Pedro Tammela</a>,
<a href="mailto:koihik@hotmail.com">Shaobang Wen</a>
</p>

<br><hr>
<h3 id="pallene">Closures in Pallene</h3>

<p><a href="https://github.com/pallene-lang/pallene">Pallene</a> is a typed
companion language for Lua. Its syntax is similar to Lua, but with added type
annotations. These types allow the Pallene compiler to generate code that is
much more efficient than the Lua interpreter. Pallene is ideally suited for
writing performant extension modules for Lua.
</p>

<p>
Pallene is evolving at a rapid pace, and there are still many features
missing from the language. One of the key missing features is function
closures. Closures allow programmers to write nested functions, where
the inner function uses variables from the outer function. They are are
important because they allow programmers to write more expressive code
with a functional paradigm. Closures are a key feature in Lua, and we
want them in Pallene to reduce the gap between the two languages.
</p>

<p>
In this project, you will delve into the guts of the Pallene compiler
to implement this feature. The compiler itself is written in Lua and C,
and it generates C code, so knowing both languages is a prerequisite.
</p>

<p>
To add closures to the Pallene language, you will need to modify the
parser, the type checker, the compiler intermediate representation, and
the code generator. Besides these changes to the compiler source code,
you will also need to update language documentation and write unit
tests tests. Finally, it would also be nice to measure the performance
of the implementation.
</p>

<p>
This is a hard project, so we are expecting students that
are looking for a challenge. Nevertheless, the student will have the
full support of the mentors. If you are interested, please contact the
mentors by email to get started with Pallene development.
</p>

<h4>Prerequisites</h4>

<p><ul>
    <li> Lua programming language
    <li> C programming language
    <li> C API for Lua
    <li> Compilers
</ul></p>

<h4>Skill Level</h4>

<p>
Hard
</p>

<h4>Mentors</h4>

<p>
<a href="mailto:hgualandi@inf.puc-rio.br">Hugo Gualandi</a>
<a href="mailto:gqligneul@gmail.com">Gabriel Ligneul</a>
</p>
