
<h2>Ideas List - Google Summer of Code 2017</h2>

<ul>
<li><a href="#luasec">
Improve the HTTPS module of LuaSec
</a></li>
<li><a href="#netbsd">
Develop I/O API for NetBSD Kernel Lua
</a></li>
<li><a href="#strava">
Lua Client for Strava V3 API
</a></li>
<li><a href="#typed">
Editor Support for Typed Lua
</a></li>
<li><a href="#peg">
Parser Generator Based on LPeg(Label)
</a></li>
<li><a href="#cgilua">
Adapt CGILua SAPI launcher to explore all WSAPI features
</a></li>
<li><a href="#ceu">
Interrupt-based drivers and libraries for C&eacute;u-Arduino
</a></li>
<li><a href="#terradroid">
Porting Terra, a tiny IoT Virtual Machine, to Android Devices.
</a></li>
</ul>

<br><hr>
<h3 id="luasec">Improve the HTTPS module of LuaSec</h3>
<h4>Brief explanation</h4>

<p>
The <a href="https://github.com/brunoos/luasec/wiki" target="_blank">LuaSec</a>
HTTPS module was built on top
of <a href="https://github.com/diegonehab/luasocket" target="_blank">LuaSocket</a>
HTTP and its current versions presents some problems due to limited integration.
</p>
<p>
The aim of this project is to improve the HTTPS module, fixing the
issues and adding some new features.
</p>

<h4>Expected results</h4>

<ul>
<li>Make the HTTPS module more self-contained, fixing the dependency problem.</li>
<li>New features: proxy and SNI (Server Name Indication).</li>
<li>Support to HTTP/2 is a plus.</li>
</ul>

<h4>Knowledge prerequisites</h4>

<ul>
<li>C, Lua, Git, HTTP protocol.</li>
</ul>

<h4>Skill level</h4>
<p>Easy / Medium</p>

<h4>Mentor</h4>
<p>
<a href="mailto:brunoos@inf.ufg.br" target="_blank">Bruno Silvestre</a>
</p>

<br><hr>
<h3 id="netbsd">Develop I/O API for NetBSD Kernel Lua</h3>

<h4>Brief explanation</h4>

<p>
<a href="http://www.netbsd.org" target="_blank">The NetBSD Operating System</a> has a
kernel-level Lua interpreter version for
<a href="http://netbsd.org/~lneto/dls14.pdf" target="_blank">scripting its kernel</a>.
For example, it allows users to
<a href="http://netbsd.org/~lneto/eurobsdcon14.pdf" target="_blank">filter packets
using Lua scripts</a>.
</p>
<p>
The main difference between kernel Lua and regular user-level Lua is
that kernel Lua has no support for standard libraries that
depend on the operating system (e.g., io and os) and for floating-point
numbers. The purpose of this project is to develop kernel Lua
libraries to provide I/O functionality to kernel scripts. This API
should provide access both for file system and network. It should be
implemented as
<a href="http://www.home.unix-ag.org/bmeurer/NetBSD/howto-lkm.html" target="_blank">
NetBSD loadable kernel modules</a>, binding the kernel internal implementation
for files and sockets user-level API.
</p>

<h4>Expected results</h4>

<ul>
<li>Kernel Lua File Library</li>
<li>Kernel Lua Socket Library</li>
<li>Documentation and Benchmarks</li>
</ul>

<h4>Knowledge prerequisites</h4>

<p>
C, Lua, OS  (and some courage :) )
</p>

<h4>Skill level</h4>

<p>
Advanced
</p>

<h4>Mentor</h4>

<p>
<a href="mailto:lneto@NetBSD.org">Lourival Vieira Neto</a>
</p>

<br><hr>
<h3 id="strava">Lua Client for Strava V3 API</h3>
<h4>Brief explanation</h4>

<p><a href="https://www.strava.com" target="_blank">Strava</a>
is a popular social network for athletes that we can use to
track cycling, running or swimming activities and share them
with our connections.
The <a href="https://strava.github.io/api/" target="_blank">Strava V3 API</a>
is publicly available and developers can use it to access Strava's dataset
for creating custom applications.
As an example, <a href="https://www.relive.cc/" target="_blank">RELIVE.cc</a> 
gets your latest Strava ride and creates a movie of your ride that is played 
with Google Earth 3D.
Although Strava allows developers to create their own applications,
its <a href="https://strava.github.io/api/#libraries" target="_blank">
library support</a> is still limited and there is no support for Lua.
</p>

<p>
The aim of this project is to create a Strava library for Lua, so
we can use it to create Strava applications with Lua.
We also expect that at least one application example should be
developed using the new library.
We would like to use 
<a href="http://github.com/andremm/typedlua">Typed Lua</a>
to define our interfaces, as we might
want to move to Typed Lua when it is released.
</p>

<h4>Expected results</h4>

<ul>
<li>A Lua Client for Strava V3 API.</li>
<li>An example application that uses the Lua library.</li>
</ul>

<h4>Knowledge prerequisites</h4>

<ul>
<li>Lua.</li>
<li>RESTful WebServices.</li>
<li>JSON.</li>
<li>Github.</li>
<li>Running, Cycling or Swimming.</li>
</ul>

<h4>Skill level</h4>
<p>Medium</p>

<h4>Mentor</h4>
<p>
<a href="mailto:amaidl@inf.puc-rio.br">Andr&eacute; Maidl</a>
</p>


<br><hr>
<h3 id="typed">Editor Support for Typed Lua</h3>

<h4>Brief explanation</h4>

<p>
<a href="http://github.com/andremm/typedlua" target="_blank">Typed Lua</a> 
is a statically typed extension of the Lua language.
Currently, Typed Lua's user interface is just a command-line compiler 
that compiles a file at a time. 
The goal of this project is threefold: first to turn the command-line
compiler into a daemon that watches a file tree for changes, recompiling
the files whenever they change, and keeping as its internal state all
the errors and types extracted from these files. This daemon, or
<i>analysis server</i>, can then answer to HTTP queries about the files
in the tree, with the answers in JSON format. Finally, editor plugins
can interface with the server to display error and autocomplete information
about the files that the programmer is currently editing.
</p>

<h4>Expected results</h4>

<p>
<ul>
<li>An analysis server for Typed Lua that watches a directory tree
and compiles any Typed Lua source files that change</li>
<li>Webservices in the analysis server that serve information (in JSON format) on
the source files in the tree about parse/type errors and type information
for autocomplete purposes</li>
<li>Editor plugins for <a href="https://atom.io" target="_blank">Atom</a>, 
<a href="https://code.visualstudio.com/" target="blank">VS Code</a>,
and <a href="https://studio.zerobrane.com/" target = "_blank">Zerobrane Studio</a> 
that connect to the analysis server</li>
</ul>
</p>


<h4>Prerequisites</h4>

<p>Knowledge of Lua, JavaScript, JSON, RESTful webservices, file watching APIs.
Knowledge of how the Typed Lua typechecker works is not necessary.</p>

<h4>Skill level</h4>

<p>
Medium
</p>


<h4>Mentor</h4>

<p>
<a href="https://www.dcc.ufrj.br/~fabiom/index.en.html">Fabio Mascarenhas</a>
</p>

<br><hr>
<h3 id="peg">Parser Generator Based on LPeg(Label)</h3>

<h4>Brief explanation</h4>

<p>
<a href="http://bford.info/pub/lang/peg" target="_blank">
Parsing Expression Grammars</a> (PEGs)
are an expressive formalism for the design and implementation of top-down parsers 
with local backtracking.
<a href="http://www.inf.puc-rio.br/~roberto/lpeg/" target="_blanl">LPeg</a> 
is a tool that provides an implementation of PEGs for Lua, while 
<a href="https://github.com/sqmedeiros/lpeglabel/" target="_blank">LPegLabel</a> 
is an extension
of LPeg with some facilities for error reporting and recovery.
</p>

<p>The goal of this project is to build a parser generator on top of LPegLabel.
This new tool should make easier the description of commom idioms and
should make error reporting more automatic.
</p>

<p>
The new parse generator will be used to (re)write parsers, such
as the <a href="https://github.com/andremm/lua-parser" target="_blank">
<i>lua-parser</i></a>.
</p>


<h4>Tools</h4>

<p>
<ul>
<li><a href="https://github.com/sqmedeiros/lpeglabel/" target="_blank">LPegLabel</a>
<li><a href="http://www.inf.puc-rio.br/~roberto/lpeg/" target="_blank">LPeg</a>
<li>Lua libraries whose parsers will be rewritten
</ul> 
</p>


<h4>Expected results</h4>

<p>
<ul>
<li>A parser generator tool
<li>The (re)writing of at least 2 parsers, including <i>lua-parser</i>, 
with the new tool.
  The description of the parsers using the new tool should be easier than using plain LPeg(Label).
<li>A proper documentation
</p>

<p>
A marginal result would be the improvement of the LPegLabel tool
based on the difficulties perceived during the project.
</p>
</ul>


<h4>Prerequisites</h4>

<p>
We expect the applicants to have a good knowledge of <i>parsing</i> and
to develop familiarity with LPeg and LPegLabel before the project starts.
The applicant should have used at least one parser generator tool,
such as yacc/bison, ANTLR, JavaCC, PEG.js, etc.
</p>

<p>
For this reason, we may ask the applicants to perform some activities
<b>before</b> the application period.
</p>

<h4>Skill level</h4>

<p>
Medium / Advanced
</p>


<h4>Mentor</h4>

<p>
<a href="https://sites.google.com/site/sqmedeiros/" target="_blank">
S&eacute;rgio Medeiros</a>
</p>

<br><hr>
<h3 id="cgilua">Adapt CGILua SAPI launcher to explore all WSAPI features.</h3>
<h4>Brief explanation</h4>

<p><a href="http://keplerproject.github.io/cgilua/" target="_blank">
CGILua</a> is a tool for creating dynamic Web pages and manipulating input
data from Web forms.  One of advantages of CGILua is its abstraction
of the underlying Web server. CGILua can be used with a variety of Web
servers and, for each server, with different launchers. A launcher is
responsible for the interaction of CGILua and the Web server, for example
mod_lua on Apache. The reference implementation
of CGILua launchers is Kepler.</p>

<p> <a href="http://keplerproject.github.io/wsapi/" target="_blank">WSAPI</a>
is an API that abstracts the web server from Lua web
applications. WSAPI provides a set of helper libraries that help with
request processing and output buffering.</p>

<p>Currently, CGILua has an implementation of an abstract underlying server
which is almost the same of WSAPI itself. This project proposes a
reimplementation of this layer (called SAPI) to explore WSAPI fully. This
should improve the performance and simplify maintenance.</p>

<h4>Expected results</h4>
<ul>
<li>Rewrite CGILua library to dispense SAPI module and use WSAPI directly.</li>
</ul>

<h4>Knowledge prerequisites</h4>
<p>Advanced Lua programming is mandatory, since both tools (CGILua and WSAPI)
are not naive software. A good understanding of the Lua environment
concept is particularly necessary in this project.</p>

<p>Web programming experience can be very helpful especially to understand
the context of use of these tools.</p>

<h4>Skill level</h4>
<p>Medium</p>

<h4>Mentor</h4>
<p>Tom&aacute;s Guisasola</p>

<br><hr>
<h3 id="ceu">Interrupt-based drivers and libraries for C&eacute;u-Arduino</h3>

<h4>Background</h4>

<p>
Currently, most operations in Arduino libraries freeze the rest of the
application until they complete:
</a>
</p>

<ul>
<li> Reading an analog pin with
<a href="https://www.arduino.cc/en/Reference/AnalogRead" target="_blank">
analogRead</a> takes about 100 microseconds to complete.
</li>
<li> Measuring distance with an
<a href="http://playground.arduino.cc/Code/NewPing" target="_blank">
ultrasonic sensor</a> takes about 30 milliseconds.
</li>
</ul>

<p>
The use of interrupts allows programs to remain executing while the operation
progresses and completes.
However, programming with interrupts is hard and error prone.
</p>

<p>
C&eacute;u-Arduino supports the development of Arduino applications in the 
programming language C&eacute;u:
</p>

<ul>
<li>Source Code:
<a href="https://github.com/fsantanna/ceu-arduino/" target="_blank">
https://github.com/fsantanna/ceu-arduino/</a></li>
<li>Documentation:
<a href="http://fsantanna.github.io/ceu-arduino/" target="_blank">
http://fsantanna.github.io/ceu-arduino/</a></li>
<li>Chat:
<a href="https://gitter.im/fsantanna/ceu" target="_blank">
https://gitter.im/fsantanna/ceu</a></li>
</ul>

<p>
C&eacute;u is a reactive language that aims to offer a higher-level and safer
alternative to C:
</p>

<ul>
<li>Home Page:
<a href="http://www.ceu-lang.org/" target="_blank">
http://www.ceu-lang.org/</a></li>
<li>Source code:
<a href="https://github.com/fsantanna/ceu/" target="_blank">
https://github.com/fsantanna/ceu/</a></li>
</ul>

<p>
C&eacute;u-Arduino empowers the development of Arduino applications with the following
extensions:
</p>

<ul>
<li>Awaiting events in direct/sequential style.  </li>
<li>Parallel lines of execution with
    <ul>
    <li>safe abortion;</li>
    <li>deterministic behavior (in contrast with threads).</li>
    </ul>
</li>
<li>Asynchronous loops for heavy computations.</li>
<li>Interrupt-driven operation mode.</li>
<li>Seamless integration with standard Arduino (e.g., <code>digitalWrite</code>,
<code>random</code>, etc).</li>
</ul>

<p>
C&eacute;u supports
<a href="https://github.com/fsantanna/ceu-arduino#switching-a-led-with-interrupts" target="_blank">
interrupts</a>
as a primitive construct, reducing programming efforts considerably.
</p>

<p>
C&eacute;u-Arduino already provides interrupt-based drivers for
<a href="https://github.com/fsantanna/ceu-arduino/tree/master/include/arduino/isr" target="_blank">
pins, internal timers, and the USART</a>.
</p>

<h4>The Project</h4>

The project consists of developing new interrupt-based drivers and libraries
for chips and peripherals, e.g.:

<ul>
    <li>Arduino's internal analog-to-digital converter.
    </li>
    <li>Arduino's internal SPI and I2C buses.
    </li>
    <li>Arduino's internal EEPROM.
    </li>
    <li>An 
<a href="http://forum.arduino.cc/index.php?topic=278270.0" target="_blank">
external real-time clock</a>.
    </li>
    <li>Some sensor libraries built on top of these drivers, e.g.:
        ultrasonic, accelerometer, etc.
    </li>
</ul>


<h4>Tools</h4>

<ul>
<li>
    <a href="https://github.com/fsantanna/ceu/" target="_blank">
C&eacute;u</a> is the programming language used in C&eacute;u-Arduino.
</li>
<li>
    <a href="https://github.com/fsantanna/ceu-arduino/" target="_blank">
C&eacute;u-Arduino</a> is the C&eacute;u binding for Arduino.
</li>
<li>
    <a href="https://www.arduino.cc/en/Main/ArduinoBoardUno" target="_blank">
Arduino UNO</a> is an Arduino development board.
</li>
<li>
    A sort of Arduino peripherals.
</li>
</ul>

<h4>Prerequisites</h4>

<p>
<b>We expect the student to own an Arduino board and peripherals.</b>
</p>

We also expect the student to know <b>C</b> and
<b>interrupt services routines</b> in Arduino or AVR microcontrollers.

<p>
We ask applicants to complete the following activities <i>before</i> the
application period:
</p>

<ol>
<li>
    Install C&eacute;u and C&eacute;u-Arduino and compile and test some existing examples.
</li>
<li>
    Create a simple example in C&eacute;u-Arduino using some sensors and actuators
    (not necessarily using interrupts).
</li>
<li>
    Create a simple example in C that uses interrupt-driven analog reads.
</li>
<li>
    Fork our <a href="https://github.com/fsantanna/ceu-arduino/" target="_blank">
C&eacute;u-Arduino</a>
    project on <i>github</i> and commit the new examples.
</li>
</ol>

<h4>Skill level</h4>

<p>
Hard
</p>

<h4>Mentor</h4>

<p>
<a href="http://www.ceu-lang.org/chico" target="_blank">Francisco Sant'Anna</a>
</p>
<br><hr>

<h3 id="terradroid"> Porting Terra, a tiny IoT Virtual Machine, to
Android Devices.</h3>
<h4>Brief explanation</h4>
<p><a href="http://www.inf.puc-rio.br/%7Eabranco/terra.html" tager="_blank">
Terra</a>
is a system based on a tiny virtual machine and combines a reactive
scripting language with a set of customized components. Originally,
Terra was designed to run in WSN/IoT nodes with limited resources.
These nodes, typically, have small microcontrolers and communicate
using specific radio standards like IEEE 802.15.4 (based on ZigBee).
Terra uses C&eacute;u-T as its scripting language and implements a
component-based virtual machine VM-T to be customized for different
application domains.
We built VM-T using the <a href="http://nescc.sourceforge.net/" target="_blank">
nesC</a> programming language and
the <a href="http://tinyos.net" target="_blank">TinyOS</a> operating system.
</p>
<p>
We have already started some initiatives to port Terra to different
devices to enable interoperability in heterogeneous IoT network. These
initiatives include ports to different operating systems and devices
with different levels of resources. These initiatives include
the use of radio technologies like IEEE 802.11 standards and the use of
Linux on a RaspberryPI device. </p>
<p>
The aim of this project is to port Terra Virtual Machine VM-T to
Android devices. This port will enable interoperability of Android
devices with others devices running Terra, allowing experiments with
more powerful mobile devices interacting with a heterogeneous IoT
network. </p>
<p>
We plan two main development activities.
One will be the development of an integration layer
between the VM engine and the Android system.
The other will be the customization to access some sensors and
actuators of the device.
</p>
<h4>Expected results</h4>
<ul>
<li>A functional port of Terra VM to Android devices.</li>
<li>A set of Terra application examples, including a gateway between
different radio standards.</li>
</ul>
<h4>Knowledge prerequisites</h4>
<ul>
<li>Android - programming in C. (Timer and UDP/IP library)</li>
<li>nesC - Desirable basic knowledge.</li>
<li>Github.</li>
</ul>
<h4>Skill level</h4>
<p>Medium</p>
<h4>Mentor</h4>
<p>
<a href="mailto:abranco@inf.puc-rio.br">Adriano Branco</a>
</p>
