
<h2>Ideas' List - Google Summer of Code 2014</h2>

<ul>
<li><a href="#cgilua">
Adapt CGILua SAPI launcher to explore all WSAPI features.
</a></li>
<li><a href="#typedlua">
Add class-based object-oriented programming to Typed Lua.
</a></li>
<li><a href="#lpeg">
Add labeled failures to LPeg
</a></li>
<li><a href="#luasoap">
Add support for WSDL generation to LuaSOAP
</a></li>
<li><a href="#luasql">
Add support for prepared statements in LuaSQL.
</a></li>
<li><a href="#luaredis">
Concurrent Lua scripts execution in Redis
</a></li>
<li><a href="#lualeak">
Create a library to help "memory leak" detection in Lua
</a></li>
<li><a href="#dynserial">
Develop a binary serialization format with support for dynamically types values and an RPC protocol for dynamically typed invocations based on this format.
</a></li>
<li><a href="#loski">
Develop a library for Lua that allows Lua programs to access features provided by the platform's underlying operating system (OS) kernel, such as process control, network access, file system, event notification, etc.
</a></li>
<li><a href="#vlc">
Multi-CPU usage in VLC
</a></li>
<li><a href="#wireshark">
Multi-CPU usage in wireshark
</a></li>
<li><a href="#gameduino">
Porting Gameduino demos to the programming language CÃ©u.
</a></li>
<li><a href="#luaproc">
Send/Receive support for main script in the luaproc library
</a></li>
<li><a href="#threadsafelua">
Thread-safe Lua
</a></li>
<li><a href="#luashare">
luashare - data sharing among parallel execution flows of Lua code
</a></li>
</ul>

<h3 id="cgilua">Adapt CGILua SAPI launcher to explore all WSAPI features.</h3>

<h4 id="briefexplanation">Brief explanation</h4>

<p>CGILua [1] is a tool for creating dynamic Web pages and manipulating input
data from Web forms.  One of advantages of CGILua is its abstraction
of the underlying Web server. CGILua can be used with a variety of Web
servers and, for each server, with different launchers. A launcher is
responsible for the interaction of CGILua and the Web server, for example
using ISAPI on IIS or mod_lua on Apache. The reference implementation
of CGILua launchers is Kepler.</p>

<p>WSAPI [2] is an API that abstracts the web server from Lua web
applications. WSAPI provides a set of helper libraries that help with
request processing and output buffering.</p>

<p>Actually CGILua has an implementation of an abstract underlying server
which is almost the same of WSAPI itself. This project proposes a
reimplementation of this layer (called SAPI) to explore WSAPI fully. This
should improve the performance and simpify maintenance.</p>

<h4 id="expectedresults">Expected results</h4>

<ul>
<li>Rewrite CGILua library to dispense SAPI module and use WSAPI directly.</li>
</ul>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>

<p>Advanced Lua programming is mandatory, since both tools (CGILua and WSAPI)
are not naive software. A good understanding of the Lua environment
concept is particularly necessary in this project.</p>

<p>Web programming experience can be very helpful especially to understand
the context of use of these tools.</p>

<h4 id="skilllevel">Skill level</h4>

<p>Medium</p>

<h4 id="mentor">Mentor</h4>

<p>Tomás Guisasola</p>

<h4 id="links">Links</h4>

<p>[1] CGILua:   <a href="http://keplerproject.github.io/cgilua/">http://keplerproject.github.io/cgilua/</a></p>

<p>[2] WSAPI:    <a href="http://keplerproject.github.io/wsapi/">http://keplerproject.github.io/wsapi/</a></p>

<h3 id="typedlua">Add class-based object-oriented programming to <a href="https://github.com/andremm/typedlua">Typed Lua</a> [1].</h3>

<h4 id="briefexplanation">Brief explanation</h4>

<p>Typed Lua is a strict superset of Lua that provides optional
type annotations, and compile-time type checking.
More precisely, Typed Lua is implemented as a programming language
that extends Lua syntax to add optional type annotations.
The compiler uses static types to perform compile-time type checking,
but also allows Lua code to coexist with Typed Lua code, and generate
Lua code that runs in unmodified Lua implementations.</p>

<h4 id="expectedresults">Expected results</h4>

<p>Typed Lua intended use is as an application language, and we view that
policies for organizing a program in modules and writing object-oriented
programs should be part of the language and enforced by its optional type
system. An application language is a programming language that helps
programmers develop applications from scratch until these applications
evolve to complex systems rather than just scripts.
This project aims to add class-based object-oriented programming to
Typed Lua through the definition of classes, interfaces, and modules,
as a way to help Lua programmers better structure their code.</p>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>

<p>Lua, Object-Oriented Programming, and Type Systems</p>

<h4 id="skilllevel">Skill level</h4>

<p>Hard</p>

<h4 id="mentor">Mentor</h4>

<p><a href="http://www.dcc.ufrj.br/~fabiom/">Fabio Mascarenhas</a> [2]</p>

<h4 id="links">Links</h4>

<p>[1] Typed Lua: <a href="https://github.com/andremm/typedlua">https://github.com/andremm/typedlua</a></p>

<p>[2] Fabio Mascarenhas: <a href="http://www.dcc.ufrj.br/~fabiom/">http://www.dcc.ufrj.br/~fabiom/</a></p>

<h3 id="lpeg">Add labeled failures to <a href="http://www.inf.puc-rio.br/~roberto/lpeg/">LPeg</a> [1].</h3>

<h4 id="briefexplanation">Brief explanation</h4>

<p>Parsing Expression Grammars (PEGs) are an expressive formalism for
designing and implementing top-down parsers with local backtracking.
However, PEGs do not support the error handling techniques that are often
implemented in top-down parsers, because these techniques assume the parser
reads the input without backtracking.</p>

<p>Parsing Expression Grammars for Lua (LPeg) is a pattern-matching tool
based on PEGs.
Although it is quick and easy to write parsers using LPeg, like PEGs, it
does not provide any support to the programmer handle parsing errors.</p>

<h4 id="expectedresults">Expected results</h4>

<p>There is an extension to the PEGs formalism that introduces <a href="http://www.inf.puc-rio.br/~roberto/docs/sblp2013-1.pdf">labeled
failures</a> as a way
to annotate and label grammar pieces that should
not fail [2].
In this approach, each label may be tied to a specific error message
and resembles the concept of exceptions from programming languages.
The aim of this project is to create a LPeg fork that implements this
error reporting technique.</p>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>

<p>C, Lua, and Parsing Expression Grammars</p>

<h4 id="skilllevel">Skill level</h4>

<p>Hard</p>

<h4 id="mentor">Mentor</h4>

<p><a href="http://www.inf.puc-rio.br/~roberto">Roberto Ierusalimschy</a></p>

<h4 id="links">Links</h4>

<p>[1] LPeg: <a href="http://www.inf.puc-rio.br/~roberto/lpeg/">http://www.inf.puc-rio.br/~roberto/lpeg/</a></p>

<p>[2] Exception Handling for Error Reporting in Parsing Expression Grammars:
<a href="http://www.inf.puc-rio.br/~roberto/docs/sblp2013-1.pdf">http://www.inf.puc-rio.br/~roberto/docs/sblp2013-1.pdf</a></p>

<p>[3] Roberto Ierusalimschy: <a href="http://www.inf.puc-rio.br/~roberto">http://www.inf.puc-rio.br/~roberto</a></p>

<h3 id="luasoap">Add support for WSDL generation to LuaSOAP</h3>

<h4 id="briefexplanation">Brief explanation</h4>

<p><a href="http://tomasguisasola.github.io/luasoap/">LuaSOAP</a> [1] is a library to
ease the use of <a href="http://www.w3.org/TR/soap/">SOAP</a> [2].  LuaSOAP provides
a very simple API that convert Lua tables to and from XML documents.
It also offers a simple way to invoke remote Web Services without having
to deal directly with SOAP messages.  In fact, LuaSOAP also provides
a simple way to offer Web Services -- the server side -- but it lacks
support for WSDL generation of the offered services.</p>

<p><a href="http://www.w3.org/TR/wsdl">WSDL</a> [3] is an XML format for describing
network services.  It is used to describe operations and messages --
with its types -- offered by Web Services.  Since Lua code does not
include type information, automatic generation has to be based on some
kind of hand-made declarative information.</p>

<h4 id="expectedresults">Expected results</h4>

<ul>
<li>Define the format to describe complementary WSDL information in Lua</li>
<li>Implement an automatic generator of WSDL documents</li>
<li>Test and document everything</li>
</ul>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>

<p>Lua programming; client-server web architecture; SOAP and WSDL specifications.</p>

<ul>
<li>Basic programming in Lua is mandatory</li>
<li>Web programming experience is very appreciated but not mandatory</li>
<li>SOAP and WSDL specifications could be learned during the project</li>
</ul>

<h4 id="skilllevel">Skill level</h4>

<p>Easy</p>

<h4 id="mentor">Mentor</h4>

<p>Tomás Guisasola</p>

<h4 id="links">Links</h4>

<p>[1] LuaSOAP:   http://tomasguisasola.github.io/luasoap/
[2] SOAP:      http://www.w3.org/TR/soap/
[3] WSDL:      http://www.w3.org/TR/wsdl</p>

<h3 id="luasql">Add support for prepared statements in LuaSQL.</h3>

<h4 id="briefexplanation">Brief explanation</h4>

<p>LuaSQL [1] is a generic interface from Lua to a DBMS.
It aims at portability over performance, but it allows extensions to
suit the particularities of each DBMS.</p>

<p>The inclusion of support for prepared statements in LuaSQL has been
discussed thoroughly some time ago, but since each DBMS offers very
different APIs there is no standard that could be defined to assure
portability between them.
Anyway the demand persists.</p>

<p>This project proposes the addition of a minimal API that would allow
each driver to implement prepared statements according to its DBMS
restrictions.</p>

<h4 id="expectedresults">Expected results</h4>

<ul>
<li>Adapt the API to each LuaSQL driver according to its particularities</li>
<li>Implement the new functions to each driver</li>
<li>Test and document everything</li>
</ul>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>

<p>C, Lua and C API for Lua:</p>

<ul>
<li>C is mandatory.</li>
<li>Knowledge of the C API for Lua is mandatory, although it is not too
difficult to be learned during the project.</li>
<li>Basic programming in Lua is very helpful, but not mandatory, since
the examples and test-cases are very simple.</li>
</ul>

<h4 id="skilllevel">Skill level</h4>

<p>Hard</p>

<h4 id="mentor">Mentor</h4>

<p>Tomás Guisasola</p>

<h4 id="links">Links</h4>

<p>[1] LuaSQL:   <a href="http://www.keplerproject.org/luasql/">http://www.keplerproject.org/luasql/</a></p>

<h3 id="luaredis">Concurrent Lua scripts execution in Redis</h3>

<h4 id="briefexplanation">Brief explanation:</h4>

<p>Redis is a popular open source key-value store that supports scripting using the Lua programming language. Howerer, Redis uses the same Lua interpreter to run all the commands so  while the script is running no other client can execute commands. The objective of this project is to support parallel script execution without loosing their atomicity and cluster support.</p>

<h4 id="expectedresults">Expected results:</h4>

<p>A fork of Redis with support for concurrent Lua scripts executions, leveraging the use of more complex and slow scripts.</p>

<h4 id="knowledgeprerequisite">Knowledge prerequisite:</h4>

<p>C, Lua, Redis, pthreads</p>

<h4 id="skilllevel">Skill level:</h4>

<p>Medium</p>

<h4 id="mentor">Mentor:</h4>

<p>Noemi Rodriguez</p>

<h3 id="lualeak">Create a library to help "memory leak" detection in Lua [1].</h3>

<h4 id="briefexplanation">Brief explanation</h4>

<p>Memory leak in garbage collected languages happens when the program allocates a
memory, then finish using it but does not free3 the memory block. In this case,
all pointers to this block and the block itself are valid, however the data
will never be accessed again by the program.</p>

<p>Lua is a dynamic typed language with garbage collection that as other
garbage-collected languages has many reported issues related to memory leak.
Your task would be to create a library to help memory leak detection in Lua.</p>

<h4 id="expectedresults">Expected results</h4>

<ul>
<li>A library that helps memory leak detection in Lua.</li>
</ul>

<p>There is no restriction if the library should:
* use a combination of heap-differencing and fine-grained allocation tracking
* detect when objects exceed their expected lifetimes
* detect when an object becomes stale
* track growing data structures to check whether they are leaking or not.</p>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>

<p>A memory leak detection tool will need to monitor and understand objects
behavior and maybe interact with the garbage collector.
Since Lua is implemented in ANSI C and this tool will need access to
the language internals, C is mandatory.</p>

<p>Understanding garbage collection techniques can be very helpful, mainly
the incremental mark-and-sweep collector technique, which Lua implements.</p>

<p>Programming in Lua is not mandatory, however, understanding the language
structure will be very important. For example, Lua has different types of
objects, but only one data structuring mechanism.</p>

<h4 id="skilllevel">Skill level</h4>

<p>Hard</p>

<h4 id="mentor">Mentor</h4>

<p>Roberto Ierusalimschy [2]</p>

<h4 id="links">Links</h4>

<p>[1] Lua:   <a href="http://lua.org/">http://lua.org/</a></p>

<p>[2] Roberto: <a href="http://www.inf.puc-rio.br/~roberto">http://www.inf.puc-rio.br/~roberto</a></p>

<h3 id="dynserial">Develop a binary serialization format with support for dynamically types values and an RPC protocol for dynamically typed invocations based on this format.</h3>

<h4 id="briefexplanation">Brief explanation</h4>

<p>Most RMI protocols available today are either focused on inefficient representation formats for typing information <a href="http://www.omg.org/spec/CORBA/3.3/Interoperability/PDF">1</a> <a href="http://hessian.caucho.com">2</a> <a href="https://developers.google.com/protocol-buffers/">3</a>, or on invocations where the typing information are predefined and static, therefore are absent on the data sent through the wire <a href="http://www.json.org">5</a> <a href="http://www.w3.org/TR/soap/">4</a> <a href="http://www.caucho.com/resin-3.0/protocols/burlap.xtp">6</a>. Few protocols are designed to work efficiently with typed data. Invocations with typed data work well with the RPC model because it allows the identification of deployment problems (mismatch interfaces) and facilitate the dynamic evolution of distributed systems. A protocol for dynamically typed RPC should be based on a efficient serialization format for typed data, that is, information about how the data should be interpreted.</p>

<p>The goal of this project is to design and implement a serialization binary serialization format with the following requirements:</p>

<ul>
<li><p>Primitive data: numeric formats (integer and floating-point), characters and boolean.</p></li>
<li><p>Structured data: serialization of usual structured data like records, arrays, maps, tuples, union, etc.</p></li>
<li><p>Optional typing: serialization of both raw data and data plus typing information.</p></li>
<li><p>Structurual compatibility: type information should allow to efficiently verify whether two types are compatibile.</p></li>
<li><p>Opaque data: allow that a special form of raw data (without typing information) can be ignored without compromising the remains of the stream and that can also be passed along by a receiver that did not interpreted it.</p></li>
<li><p>Semantic information: data types that can extend a standard type with additional semantic information, like a string (sequence of characteres) with an associated charset or a record with an associated class name that provides some behavior over the data on the record.</p></li>
<li><p>Graphs: data with cyclic references.</p></li>
</ul>

<h4 id="expectedresults">Expected results</h4>

<ul>
<li>An specification of a binary serialization format with support for typed data.</li>
<li>An implementation of a library for encoding values using this format.</li>
</ul>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>

<ul>
<li>Basic programming skills (preferably C or Lua).</li>
</ul>

<h4 id="skilllevel">Skill level</h4>

<p>Hard</p>

<h4 id="mentor">Mentor</h4>

<p>Renato Maia</p>

<h4 id="links">Links</h4>

<p><a href="http://www.omg.org/spec/CORBA/3.3/Interoperability/PDF">1</a> GIOP/IIOP (CORBA) <a href="http://www.omg.org/spec/CORBA/3.3/Interoperability/PDF">http://www.omg.org/spec/CORBA/3.3/Interoperability/PDF</a></p>

<p><a href="http://hessian.caucho.com">2</a> Hessian <a href="http://hessian.caucho.com">http://hessian.caucho.com</a></p>

<p><a href="https://developers.google.com/protocol-buffers/">3</a> Google Protocol Buffers <a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p>

<p><a href="http://www.json.org">5</a> JSON <a href="http://www.json.org">http://www.json.org</a></p>

<p><a href="http://www.w3.org/TR/soap/">4</a> SOAP <a href="http://www.w3.org/TR/soap/">http://www.w3.org/TR/soap/</a></p>

<p><a href="http://www.caucho.com/resin-3.0/protocols/burlap.xtp">6</a> Burlap <a href="http://www.caucho.com/resin-3.0/protocols/burlap.xtp">http://www.caucho.com/resin-3.0/protocols/burlap.xtp</a></p>

<h3 id="loski">Develop a library for Lua <a href="https://github.com/renatomaia/loski">1</a> that allows Lua programs to access features provided by the platform's underlying operating system (OS) kernel, such as process control, network access, file system, event notification, etc.</h3>

<h4 id="briefexplanation">Brief explanation</h4>

<p>Standard Lua distribution is based mostly on standard ANSI C libraries only. Therefore, many functionalities provided by modern platforms (like process control, file system operations, network communication, kernel event notification, etc.) are only available through third-party libraries that are developed independently and might not integrate.</p>

<p>The project has three main goals:</p>

<ul>
<li><p>Design a simple and easy API that allows for different implementations over various platforms (POSIX, Linux, MacOSX, Windows, etc.) yet allowing use of a basic set of features that are provided by most popular plataforms.</p></li>
<li><p>Design an internal architecture that facilitate the replacement of the actual implementation of the features provided by the library (create process, use sockets, inspect file systems, etc). This is important to make porting the library to other platoforms easier.</p></li>
<li><p>Provide a basic/standard implemenation of features provided by the library based on the codebase of existing Lua libraries that already export features of the underlying platform like LuaSocket<a href="http://w3.impa.br/~diego/software/luasocket/">2</a>, LuaFileSystem<a href="http://keplerproject.github.io/luafilesystem/">3</a> and others.</p></li>
</ul>

<h4 id="expectedresults">Expected results</h4>

<p>A set of Lua libraries implemented at least in one major operating system platform. The library shall provide support for:</p>

<ul>
<li>Creation and manipulation of processes, and possibly inter-process comunication mechanisms, such as pipes.</li>
<li>Creation and maniputation of sockets (TCP and UDP).</li>
<li>Inspection of the local file system, possibly including file attributes and permissions.</li>
<li>Notification of kernel events like process termination, socket data availability, file modification, etc.</li>
</ul>

<p>The implementation shall also be flexible enough to facilitate the portability for other platforms.</p>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>

<ul>
<li>Programming in C.</li>
<li>Familiarity with concepts of the Lua language.</li>
<li>Programming with the system API of some popular platform, such as Linux, FreeBSD, Windows, etc.</li>
</ul>

<h4 id="skilllevel">Skill level</h4>

<p>Hard</p>

<h4 id="mentor">Mentor</h4>

<p>Renato Maia</p>

<h4 id="links">Links</h4>

<p><a href="https://github.com/renatomaia/loski">1</a> Prototype at <a href="https://github.com/renatomaia/loski">https://github.com/renatomaia/loski</a></p>

<p><a href="http://w3.impa.br/~diego/software/luasocket/">2</a> LuaSocket <a href="http://w3.impa.br/~diego/software/luasocket/">http://w3.impa.br/~diego/software/luasocket/</a></p>

<p><a href="http://keplerproject.github.io/luafilesystem/">3</a> LuaFileSystem <a href="http://keplerproject.github.io/luafilesystem/">http://keplerproject.github.io/luafilesystem/</a></p>

<h3 id="vlc">Multi-CPU usage in VLC</h3>

<h4 id="briefexplanation">Brief explanation:</h4>

<p>VLC is a free and open source cross-platform multimedia player and framework that plays most multimedia files as well as DVD, Audio CD, VCD, and various streaming protocols. Lua scripts can be added to VLC for tasks such as playlist construction and service discovery. Such tasks may involve a lot of parsing and communication and could benefit from using multiple CPUs when available. The purpose of this project is to include support for multi-CPU usage in VLC, using luaproc, a library that allows programmers to create multiple independent execution flows of Lua code that can run inparallel, communicating only via message-passing.</p>

<h4 id="expectedresults">Expected results:</h4>

<p>Multi-CPU support in VLC.</p>

<h4 id="knowledgeprerequisite">Knowledge prerequisite:</h4>

<p>C, Lua</p>

<h4 id="skilllevel">Skill level:</h4>

<p>Medium</p>

<h4 id="mentor">Mentor:</h4>

<p>Noemi Rodriguez</p>

<h3 id="wireshark">Multi-CPU usage in wireshark</h3>

<h4 id="briefexplanation">Brief explanation:</h4>

<p>The wireshark network protocol analyser [1] allows programmers to use Lua to write dissectors, post-dissectors and taps. Dissectors are protocol analysers, while post-dissectors are executed after all others dissectors, and taps are used to collect information after packet dissection. Protocol dissection can involve time constraints, and it would be nice to benefit from multi-CPU processing power in dissector script. The purpose of this project is to include support for multi-CPU usage in wireshark, using luaproc, a library that allows programmers to create multiple independent execution flows of Lua code that can run inparallel, communicating only via message-passing.</p>

<h4 id="expectedresults">Expected results:</h4>

<p>We expect the support for Multi-CPU usage in wireshark.</p>

<h4 id="knowledgeprerequisite">Knowledge prerequisite:</h4>

<p>C, Lua</p>

<h4 id="skilllevel">Skill level:</h4>

<p>Medium</p>

<h4 id="mentor">Mentor:</h4>

<p>Noemi Rodriguez</p>

<p>[1] http://www.wireshark.org/</p>

<h3 id="gameduino">Porting Gameduino demos to the programming language CÃ©u.</h3>

<h4 id="briefexplanation">Brief explanation</h4>

<p>Gameduino [1] is an Arduino-based [2] open-source hardware platform for games.
It is composed of a touchscreen, an embedded GPU, headphone jack, 
accelerometer, and a microSD slot.
The associated software package contains dozen of demos and four complete games 
(e.g.  Space Invarders and Chess) developed in C.
Gameduino was a successful Kickstarter project in 2013 [3].</p>

<p>CÃ©u [4] is a concurrent programming language that offers a safer and 
higher-level alternative to C.
It targets embedded systems such as Arduino.
CÃ©u was designed in the Lablua.</p>

<h4 id="expectedresults">Expected results</h4>

<ul>
<li>Port the Gameduino demos from C to CÃ©u.</li>
<li>Compare the codebases in C and CÃ©u with respect to quantitative 
measures such as lines of code, memory consumption and CPU usage.</li>
</ul>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>

<p>C and CÃ©u:</p>

<ul>
<li>C is mandatory.</li>
<li>CÃ©u is a C-based language and can be learned during the project.</li>
</ul>

<h4 id="skilllevel">Skill level</h4>

<p>Medium</p>

<h4 id="mentor">Mentor</h4>

<p>Francisco Sant'Anna is a post-doc at Lablua and the designer of CÃ©u.</p>

<h4 id="links">Links</h4>

<p>[1] Gameduino:   <a href="http://excamera.com/sphinx/gameduino2/">http://excamera.com/sphinx/gameduino2/</a></p>

<p>[2] Arduino:     <a href="http://arduino.cc/">http://arduino.cc/</a></p>

<p>[3] Kickstarter: <a href="https://www.kickstarter.com/projects/2084212109/gameduino-2-this-time-its-personal">https://www.kickstarter.com/projects/2084212109/gameduino-2-this-time-its-personal</a></p>

<p>[4] CÃ©u:  <a href="http://www.ceu-lang.org/">http://www.ceu-lang.org/</a></p>

<h3 id="luaproc">Send/Receive support for main script in the luaproc library</h3>

<h4 id="briefexplanation">Brief explanation</h4>

<p>luaproc is a concurrent programming library for the Lua
programming language. It allows programmers to create multiple independent
execution flows of Lua code, called Lua processes, that can run in
parallel with underlying multithreading support. Lua processes can only
communicate through message passing. However, the main Lua script from
where the library is loaded and initial Lua processes are created, cannot
send or receive messages. The purpose of this project is to implement the
required changes in luaproc to allow the main Lua script to communite with
spawned Lua processes through message passing.</p>

<h4 id="expectedresults">Expected results</h4>

<p>An updated version of the luaproc library where it is
possible for the main Lua script to send messages to and to receive
messages from spawned Lua processes.</p>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>

<p>C, Lua, pthreads</p>

<h4 id="skilllevel">Skill level</h4>

<p>Medium</p>

<h4 id="mentor">Mentor</h4>

<p>Noemi Rodriguez</p>

<h3 id="threadsafelua">Thread-safe Lua</h3>

<h4 id="briefexplanation">Brief explanation</h4>

<p>The Lua programming language includes cooperative
multithreading support through coroutines. However, this form of
multithreading is not designed to exploit parallelism. The Lua C API
allows programmers to create independent Lua states, which store
interepreter-related data, that can be used to execute code as if it was
executed from within a coroutine. This has been used by libraries, such as
luaproc and Lua Lanes, to implement concurrency models based on system
threads that can exploit parallelism. The Lua C API also allows
programmers to create new (userland) threads within the same Lua state.
These threads share data with the parent state and thus can potentially
lead to race conditions if executed in parallel. The purpose of this
project is to implement a fork of the standard Lua interpreter that is
internally thread-safe, i.e., that allows multiple (userland) threads
within the same Lua state to execute in parallel without internal
interpreter data races.</p>

<h4 id="expectedresults">Expected results</h4>

<p>A fork implementation of the latest version of the
interpreter of the Lua programming language that is internally
thread-safe.</p>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>

<p>C, Lua, pthreads</p>

<h4 id="skilllevel">Skill level</h4>

<p>Hard</p>

<h4 id="mentor">Mentor</h4>

<p>Noemi Rodriguez</p>

<h3 id="luashare">luashare - data sharing among parallel execution flows of Lua code</h3>

<h4 id="briefexplanation">Brief explanation</h4>

<p>luaproc is a concurrent programming library for the Lua
programming language. It allows programmers to create multiple independent
execution flows of Lua code, called Lua processes, that can run in
parallel with underlying multithreading support. Lua processes can only
communicate through message passing. However, messages cannot hold tables,
only basic data types like numbers, strings and booleans. To send tables,
programmers must serialize data on the sender and de-serialize it on the
receiver. Apart from the implementation overhead, there can also be a
performance cost to serialize and de-serialize data. Therefore, it would
be useful to allow table references to be sent in messages, so instead of
copying data, memory would be shared. Assuming the Lua interpreter is
thread-safe, the purpose of this project is to implement a variation of
the luaproc library where instead of having completely independent Lua
processes, data could be shared, in a controlled way, among Lua processes.</p>

<h4 id="expectedresults">Expected results</h4>

<p>new concurrent programming library for the Lua programming language,
based on the principles of the luaproc programming library, that would
allow for controlled data sharing among parallel execution flows of Lua code.</p>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>

<p>C, Lua, pthreads</p>

<h4 id="skilllevel">Skill level</h4>

<p>Medium</p>

<h4 id="mentor">Mentor</h4>

<p>Noemi Rodriguez</p>

